//                    Многомерные массивы
// Двумерные массивы: если строки тип данных то это таблица, если числа тип данных то это матрица
//переменная строк именуется row или  i, переменная столца именуется column или j

// int[,] doubleArray=new int[2,4]; // инициализируем двумерный массив, перый способ
// int[,] another = {{1,2,3,4},{5,6,7,8}}; // другой способ инициализации, т е это массив с 2 строками и 4 столбцами/
// // От 1 до 8 это элементы, индексы строк и столбцов с 0 начинаются

// //Синтаксис обращения к элементам массива:
// Console.WriteLine(another[0,1]); // т е мы обращаемся к 2 сейчас

// //Но! в памяти компа многомерные массивы расположены последовательно, многомерность на самом деле абстрактна

// void PrintDoubleArray(int[,]array) // пишем метод напечатать массив двумерный
// {
//     for (int i = 0; i < array.GetLength(0); i++)
//     {
//         for (int j = 0; j < array.GetLength(1); j++)
//         {
//             Console.Write(array[i,j]+ " ");
//         }
//         Console.WriteLine();
//     } 

// }

// PrintDoubleArray(another);
// PrintDoubleArray(doubleArray);

// //                                  Зубчатый массив/массив массивов
// //есть 2 индексатора [указывает на адреса других одномерных массивов] [указывает индекс элемента в одномерном массиве]

// //Синтаксис объявления двумерного зубчатого массива

// int[][] jaggedArray=new int[3][]; // один из индексаторов должен быть указан обязательно
// // т е здесь я объявила двумерный зубчатый массив из 3 одномерных
// // т е сейчас в пямяти выделилось 3 ячейки, пока они пусты
// //чтобы их заполнить надо обратится к переменной jaggedArray

// jaggedArray[0]=new int[2]; // т е теперь в нулевой ячейке длежит указание на место в памяти где лежит одномерный массив на 2 элемента
// // остальные ячейки массива jaggedArray пока пусты, там нулл, нет ссылки которая куда то бы указывала 
// // заполним их тоже
// jaggedArray[1]=new int[3]; // теперь первая ячейка указывает на место в памяти где лежит одномерный массив на 3 элемента
// jaggedArray[2]= new int[1]; // в последней ячейке лежит информация о одномерном массиве на одну ячейку

// // напишем метод который будет выводить двумерный зубчатый масив
// Console.WriteLine();

// void PrintjaggedArraty(int[][]array)  //отличие в объвлении массива, 2 индексатора
// {
//     for (int i = 0; i < array.Length; i++) // отличие в задании длина массива, сначала обращаемся  к самомому первому массиву как к одномерному
//     {
//         for (int j = 0; j < array[i].Length; j++) // здесь обращаемся к массиву по первому индексатору, затем через точку к его свойсьву длины
//         {
//             Console.Write(array[i][j]+ " "); // здесь надо указать 2 индексатора и их значения
//         }
//         Console.WriteLine();
//     } 
    

// }

// PrintjaggedArraty(jaggedArray);

// //зубчатые массивы, используются в тех задачах, когда нужна многомерность, но каждое измерение надо заполнять не полностью
// // и у многомерных массивов элементы в памяти компа располагается компактнее, но доступ к ним через функции и из за этого обращаться к элементам массива дольше, в отличие от зубчатых
// //многомерные массивы в памяти компа хранятся так же как и одномерные, т е последовательно, зубчатые не так
// Console.WriteLine();
// void FilljaggedArrey(int[][]arr)  // написали метод заполнения массива цифрами
// {
//     for (int i = 0; i < arr.Length; i++)
//     {
//         for (int j = 0; j <arr[i].Length; j++)
//         {
//             arr[i][j]=(i+1)*(j+1);
//         }
//     }
// }

// FilljaggedArrey(jaggedArray);
// PrintjaggedArraty(jaggedArray);

                   //      Рекурсия
//напишем метод поиска факториала

// int countFactorial(int number)
// {
//     if(number==1)return 1; // так как !1=1 как и 0!=1
//     else
//     {
//         return number*countFactorial((number-1)); // есть понятие глубины рекурсии, те при каждом вызове функции самой себя она опускается вниз,
//         //а результаты уже выводятся в обратном порядке последовательно наверх этаж за этажом
//         // т о промежуточные значения нигде не хранятся, они передаются выше и возвращается только конечный результат
//     }
// }
//  int x=countFactorial(3);
//  Console.WriteLine(x);

// //пример рекурсии это обход директорий в ОС, директории хранятся в памяти в виде дерева
// // рекурсия широко применяется в алгоритмах сортирок, ИИ, машинного обучения, обход деревьев директорий
// //рекурсивные варианты многих процедур выполняются медленее итерационных эквивалентов из за затрат системных ресурсов на неоднократные вызовы функции
// // т е рекурсия не всегда нужна т к может в определенный момент привести к зависанию

// //перепишем факториал через цикл методом

// int cicleFactorial(int number)
// {
//     int result=1; //это переменная буфер
//     for (int i = 2; i <= number; i++)
//     {
//         result*=i;
//     }

//     return result;  // т е в случае с факториалом, использование рекурсии не оправдано, это пример плохого кода, здесь цикл работает быстрее

//}

// псевдокод обхода деревьев директорий 

// Папка  // структура папки описана
// {
//     Папка[] дочерниеПапки;
//     Строка наименованиеж 
// }

// ВыводДиректории(Папка) 
// {
//     ВыводИмениПапки(Папка)
//     Цикл для каждого дочернего в папке
//     {
//         ВыводДиректории(дочернего)
//     }
// }

//                                    цикл форыч=для каждого

int[] arr={1,2,3,4,5};
foreach (int element in arr) // здесь не надо использовать индексаторы, здесь внутри итераторы зашиты, 
//которые берут элементы в последовательности или коллекции и поочередно каждый элемент берут для обработки внутри итерации
//синтаксически объявляется переменная элемент и на каждой итерации она будет менять свое значение,
// которое будет брать из последовательности которую мы укажем
{
    Console.WriteLine(element);
}


















